# DDD 3장

## 3-1. 애그리거트
### 애그리거트 개념 배경
- 전체 도메인 구조 (Like ERD?)로는 큰 틀에서 데이터 구조 이해하기 어려움.
- 이는 결국 코드를 변경하고 확장하는 것이 어려워진다는것을 의미함.
- 이를 해결하기 위해 **상위 수준에서 모델을 조망할 수 있는 방법**이 필요함.
- **애그리거트**는 이처럼 관련된 객체를 하나의 군으로 묶어줌

### 애그리거트 특징
- 위 개념 배경과 마찬가지로 모델을 이해하는데 도움을 줌.
- 다른 말로, 복잡한 도메인을 **단순한 구조**로 만들어줌
- 결국 이는 도메인 기능 확장&변경에 들어가는 공수를 줄여줌.
- 도메인 로직을 애그리거트에서 관리하기에, 일관성 관리하는데도 도움을 줌.
- 애그리거트 내 구성요소는 애그리거트와 유사한 or 동일한 라이프사이클 가짐.

### 애그리거트 경계 (Boundary)
- 한 애그리거트 내 객체는 다른 애그리거트에 중복으로 속하지 않음.
- 애그리거트는 독립된 객체 군으로, 다른 애그리거트를 관리하지 않음.
- 일반적으로 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속함.
- A가 B를 가진다고 해도, A와 B가 한 애그리거트가 아닐 수도 있음.
- - i.e. Product & Review => 서로의 라이프사이클도 다를 뿐더러, 변경하는 주체도 다름 

## 3-2. 애그리거트 루트
### 애그리거트 루트 엔티티
- 애그리거트에 속한 모든 객체들이 일관되려면, 그 애그리거트들을 관리할 주체가 필요
- 이를 **애그리거트의 루트 엔티티** 라고 함.
- 이는 다시말하면 애그리거트의 대표 엔티티 이기도 함.
- 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직or간접적으로 속함

### 도메인 규칙과 일관성
- 애그리거트 루트의 또다른 역할로, **애그리거트의 일관성이 깨지지 않도록** 관리함.
- - 예를 들어, 배송 시작 전에만 배송지 정보를 바꿀 수 있다면 => 애그리거트에 해당 로직 포함.
- 불필요한 중복 피하고, 애그리거트 루트로만 도메인 로직 구현토록 하려면
- - 필드 변경용 setter를 public으로 만들지 않아야하고
- - Value 타입은 불변 형태로 구현해야 함.
- 즉, 애그리거트 외부에서 내부 상태(field)를 임의로 변경하지 못하게 막음.

### 애그리거트 루트의 기능 구현
- 애그리거트 루트 내에 도메인 로직을 구현하자!
- 예를 들어, 주문에서 상품이 추가되었을때, Order의 totalPrice 수정 + OrderList에 상품 추가가 필요함. 이를 애그리거트 루트에서 한 함수로서 구현
- 혹은 내부 애그리거트의 기능 실행을 대행하기도 함. 내부 애그리거트 상태 변경 함수를 바로 노출하지 않고, 애그리거트 루트가 이를 실행토록 함.

### 트랜잭션 범위
- 트랜잭션 범위는 작을수록 (최소한이 될수록) 테이블을 덜 락거니까 좋다.
- 한 트랜잭션에서는 한개의 애그리거트만 수정해야함. (그렇지 않으면 TX 충돌 가능)
- 한 애그리거트 안에서 다른 애그리거트 상태 변경을 지양해야한다는 뜻.
- 두개 애그리거트가 동시에 TX로 묶여야한다면 응용 계층 (Service, Use-Case) 사용
- Or, 도메인 이벤트를 사용해 동기/비동기로 타 애그리거트 상태 전파

## 3-3. 리포지터리와 애그리거트
- 애그리거트 = 개념상 한개의 도메인 모델, so, 레포지토리도 애그리거트 단위로 존재.
- 즉, Order-OrderLine이 다른 테이블이라고 해도, 레포는 하나만(OrderRepo) 존재.
- 불러올때나 저장할때나 모두 애그리거트에 속한 전체를 persist 해야함.

## 3-4. ID를 이용한 애그리거트 참조
### 한 애그리거트 내에서 다른 애그리거트를 객체 형태로 참조하면?
- 편하게 탐색하다가, 의도치 않게 다른 애그리거트 값을 건드리고싶을수도 있음.
- 애그리거트를 직접 참조하면 성능(n+1, lazy, eager 등)을 고려해야함.
- 확장성 (MSA로의, 혹은 서비스간 다른 DB 사용 등)이 떨어짐.

### so, ID를 사용한 간접 참조
- ID 참조를 쓰면 애그리거트 내의 객체들은 Object형태로 참조, 그외에는 ID값만
- 이는 물리적 연결을 줄이기에 모델의 복잡도 낮춰줌
- 애그리거트간 의존을 제거하므로 응집도도 높여줌
- 당연히, 위의 성능 관련 고민도 안해도 됨.
- 또한 애그리거트간의 다른 DB 구현 기술 사용 가능.

### 하지만, 조회 성능?
- N+1 문제 발생 가능. 기존엔 그냥 Join해서 한번에 긁을걸 이젠 id별로 하나씩 긁어서 꺼내야하니까.
- 그래서.. 직접 조회 쿼리를 JOIN걸어서 날리자? (EntityManager?)
- JPQL, QueryDSQL등을 써서 한번에 긁어봐라~ 약간 이런 느낌s..
- 혹시 두 애그리거트가 다른 DB쓰면, 캐시나 Read-Replica 등을 사용하자

## 3-5. 애그리거트 간 집합 연관
- 앞선 2장에 했던 질문인 1:n 관련 문제가 언급됨.
- 개념상 애그리거트에 1:n 연관이 있어도, 성능 문제로 실제 1:n 연관을 구현에 반영하지 않는다!?
- 카테고리:상품 => 1:n 관계
- 이럴때, 그냉 상품의 categoryId로 카테고리에 속한 n개 상품을 productRepo에서 꺼내옴.
- m:n도 마찬가지로, 요구사항에 맞춰서 구성하면 됨.
- 3-4장과 연계하여, 실제 Product-Category가 n:m일때, Product클래스 내에 Set\<CategoryId\>가 존재하는 형태.

## 3-6. 애그리거트를 팩토리로 사용하기
- 예를 들어, 상점이 blocked면, 상품을 생성하지 못하게 하려면?
- 응용 계층에서 체킹 로직을 넣어도 되겠지만, 아에 상점에 Product 생성해주는 팩토리를 집어넣어!
- **store.createProduct(그에 필요한 인자)** => 요런 형태로, store안에서 precondition 먼저!
- 애그리거트 내의 데이터를 활용해 다른 애그리거트를 생성하는 케이스에 활용