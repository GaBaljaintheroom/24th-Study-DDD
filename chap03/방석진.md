## 애그리거트

복잡한 도메인을 보다 상위 수준에서 조감하듯 바라볼 수 있게 만드는 것이 애그리거트이다. 애그리거트는 관련된 객체를 하나의 군집으로 묶어준다.

#### 애그리거트를 구분하는 기준

애그리거트는 관련된 모델을 하나로 모은 군집이기 때문에, **한 애그리거트에 속한 객체는 유사하거나 비슷한 lifecycle**을 가진다. 예를들어, 주문 애그리거트를 만들려면 `Order`, `OrderLine`, `Orderer`와 같은 객체를 함께 생성해야한다.

애그리거트의 경계를 설정할 때 기본이 되는 것은 도메인의 요구사항이다. 라이프사이클, 혹은 변경의 전파가 상호 종속적일수록 두 객체는 한 애그리거트에 속할 가능성이 높다.

#####

#### 소유 관계가 애그리거트의 기준이 될 수 있을까? No

흔히 'A가 B를 갖는다'로 풀어낼 수 있다면 그 둘을 한 애그리거트로 묶어서 생각하기 쉽다. 대개 맞을 수 있지만, 항상 그런 것은 아니다. Product와 Review가 대표적인 반례이다.

분명 Product는 Review를 소유한다. Review는 Product 없이는 존재할 수 없으며, 대게 함께 불러와지는 요구사항이 많다.

그렇지만 Product와 Review는 _Lifecycle 측면에서 매우 다르다_.

- 생성 주체

  - Product: 상품 담당자
  - Review: 제품의 고객

- 함께 생성되지도 않고, 함께 변경되지도 않는다.

## 애그리거트 루트

애그리거트 루트는 **애그리거트에 속한 모든 객체가 일관된 상태를 유지**할 수 있도록 관리자의 역할을 수행한다. = 애그리거트의 일관성 (integrity)를 보장하는 역할!

- 예를들면 데이터 일관성이다. `OrderLine`을 변경하면, `Order`의 `totlaAmounts`도 다시 계산해서 총 금액이 맞아야 한다.

이러한 측면에서 애그리거트 루트 엔티티는 애그리거트의 대표 엔티티이며, 애그리거트에 속한 객체들은 루트 엔티티에 직/간접적으로 속하게 된다.

따라서, 애그리거트을 일관적으로 관리하기 위해서는 **애그리거트의 상태를 변경하고자 할 때, 1차적으로 애그리거트 루트를 통할 수 있도록** 도메인 로직을 구현한다. 물론 세부적인 도메인 로직은 각 모델에서 구현하도록 하자.

애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안된다. 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다.

이를 위한 좋은 습관 2가지는 다음과 같다:

1. 불필요한 setter 메서드를 public하게 만들지 않는다.

   도메인의 의미나 의도를 파악하고 필드를 변경해야하는데, setter가 어디서든 접근할 수 있다면? 재앙이 곳곳에서 터진다..

2. value 타입은 immutable로 구현한다

#### one transaction, one aggragate

> 트랜잭션 범위는 작을수록 좋다. 한 트랜잭션이 한 개의 테이블을 수정하는 것과 세 개의 테이블을 수정하는 것을 비교하면 성능에서 차이가 발생한다. 한 개의 테이블을 수정하면 race condition을 막기 위해 잠그는 대상이 한 개의 테이블의 한 행으로 한정되지만, 세 개의 테이블을 수정하면 잠금 대상이 더 많아진다. 그만큼 많은 시간이 블로킹되는 것이고, 그만큼 전체적인 처리량을 줄어뜨린다.

**한 트랜잭션에서는 한 개의 애그리거트만 수정하는 것을 권장한다.** = 애그리거트에서 다른 애그리거트를 변경하지 않는다는 원칙

부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야한다면 애그리거트 내부에서 외부 애그리거트를 직접 수정하지 말고, 보다 상위 layer인 응용 서비스 layer에서 두 애그리거트를 수정하도록 구현하자.

다음과 같은 경우에는 단일 트랜잭션에서 2개 이상의 애그리거트를 변경하는 것을 고려할 수 있다:

- 팀 표준: 팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야하는 경우
- 기술 제약: 기술적으로 이벤트 방식을 도입할 수 없는 경우, 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 처리한다.
- UI 구현의 편리: 운영자의 편리함을 위해서 상태를 한번에 변경할 경우.

## 리포지터리와 애그리거트

리포지터리는 애그리거트 단위로 존재한다. 즉, **일반적으로는 애그리거트 루트를 위한 리포지터리**만 존재할 것이다. 예를들어, 주문 애그리거트에는 Order를 위한 OrderRepository만 존재한다.

#### 저장할 때에도 Aggregate 전체를 영속화한다

애그리거트는 개념적으로 하나이므로 Repository는 '애그리거트 전체'를 저장소에 영속화해야한다. 예를들어 Order 애그리거트와 관련된 테이블이 3개라면, OrderRepository를 이용해서 애그리거트를 저장할 때 애그리거트 루트인 `Order`와 매핑되는 테이블 뿐 아니라, 애그리거트에 속한 모든 구성요소에 매핑된 테이블에 데이터를 저장해야한다.

#### 불러올 때에도 완전한 Aggregate를 불러온다

동일하게, 애그리거트를 조회하는 메서드 역시 '완전한 애그리거트'를 제공해야한다.

> Question
>
> 불필요한 join을 감수하면서 매번 모든 애그리거트를 완전히 가져와야 하는가?
>
> 최적화된 별개의 Repository 메서드를 제공하면 안될까?
>
> 애그리거트의 크기를 줄여야 한다는 것이 이런 의미와도 일맥상통한다고 느꼈다.

## 애그리거트 참조관계

애그리거트 내 모델이 외부의 애그리거트와의 관계를 맺는 경우는 흔하다. 다음의 예시를 확인해보자.

- 주문 애그리거트 내에 `Order` 엔티티와 `Orderer` 엔티티가 존재한다.
- 그리고 `Orderer` 엔티티는 멤버 애그리거트의 `Member` 엔티티와 연관관계를 맺는다. (테이블 상에서나, 도메인 로직 상에서나)

이 때 외부의 애그리거트와의 참조관계를 설정하는 방식은 대표적으로 두 가지가 있다.

#### 필드로 다른 애그리거트를 참조하는 방식

JPA와 같은 ORM을 활용한다면, 간단한 어노테이션과 객체 참조 그래프를 통해서 손쉽게 다른 애그리거트와의 관계를 정의할 수 있다. 하지만 편리성 뒤에는 고려해야할 문제상황들이 다수 존재한다.

1. 외부 애그리거트를 수정하고픈 욕구

   편리하게 객체 참조를 통해 외부 애그리거트를 접할 수 있다보니, 외부 애그리거트의 모델을 직접 수정하는 메서드를 구현하고픈 유혹이 생길 수 있다.

   이는 두 애그리거트의 결합도를 높이는 안티패턴이다.

2. 성능에 대한 고민

   다른 애그리거트를 필드를 통해 직접 참조하면 성능과 관련된 여러 고민을 해야한다. JPA를 사용할 경우, Lazy 로드와 Eager 로드의 두가지 방식으로 로딩할 수 있다. 요구사항에 따라 적절한 로드방식을 채택하도록 하자.

3. 확장에 닫혀있다.

   만약 두 애그리거트의 영속성을 관리하는 Infra Layer가 다르다면?

#### ID로 다른 애그리거트를 참조하는 방식

DB 테이블에서 foriegn key로 참조하는 것과 비슷하게 ID를 이용한 참조는 다른 애그리거트를 참조할 때 엔티티의 ID를 사용한다.

```java
public class Order {
  private Orderer orderer;
}

public class Orderer {
  private MemberId memberId;
  private String name;
}

private class Member {
  private MemberId id;
}
```

Lazy 로드니 Eager 로드니 자동으로 제공하는 기능이 없어졌다. 따라서 고민할 거리도 줄었고, 복잡도도 줄었다. (물론 구현의 내용은 늘었지만) 필요한 경우에 따라 상위 Layer에서 로딩 해주면 된다. 더이상 ORM의 마법에 의존하지 않는다.

하지만 쉽게만 생각하면 또 다른 문제가 나타난다···

##### N+1 문제 해결하기

For loop으로 무지성 구현을 한다면, 한 애그리거트를 끌어올 때 query가 겁나게 많이 나가는 N+1 문제가 발생할 수 있다.

이를 해결하기 위한 가장 쉬운 방식은? 객체 참조 방식으로 회귀한 후, 옵션을 Eager 로딩으로 변경하는 것이지만, 객체 참조 방식으로 회귀하는 것은 지양하도록 하자.

조회 전용 쿼리를 사용하는 것이 하나의 방법이다.

```java
@Repository
public class JpaOrderViewDao implements OrderViewDao {
  @PersistenceContext
  private EntityManager em;

  @Override
  public List<OrderView> selectByOrderer(String ordererId) {
    String selectQuery = "";	// 여기서 한번에 join으로 가져오는 query를 작성한다.
    TypedQuery<OrderView> query = em.createQuery(selectQuery, OrderView.class);
    query.setParameter("ordererId", ordererId);
    return query.getResultList();
  }
}
```

## 애그리거트를 팩토리로 사용하기

별도의 도메인 서비스나 팩토리 클래스를 만들기보다는, 애그리거트 내부에서 팩토리 메서드를 구현할 수도 있다.

애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해보자.

생성할 때 지켜야할 도메인 로직을 애그리거트 내부에 둠으로서, 도메인의 응집도를 높일 수 있다.
