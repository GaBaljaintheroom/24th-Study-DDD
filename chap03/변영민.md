# 3. 애그리거트

## 3.1. 애그리거트란?

- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들기 위한 개념
- 상위 수준에서 도메인 간의 관계를 파악할 수 있게 도와줌
- 한 애그리거트에 속한 객체들은 유사하거나 동일한 라이프사이클을 갖음
  - ex) 주문 애그리거트를 만들려면 Order, OrderLine, Orderer와 같은 관련 객체를 함께 생성해야 함
- 각 애그리거트는 독립적이며, 다른 애그리거트를 관리하지 않음
  - ex) 주문 애그리거트에서 배송지를 변경하거나, 주문 상품 개수를 변경하지만, 회원의 비밀번호를 변경하거나 상품의 가격을 변경하지 않음
- 한 개의 엔티티 객체만 갖는 애그리거트가 많음

## 3.2. 애그리거트 루트

### 예시: 주문 애그리거트

- 주문 애그리거트는 Order가 루트이며, 배송지 변경, 상품 변경 등의 기능을 제공
- 구매할 상품의 개수를 변경하면 OrderLine의 quantity를 변경하고 더불어 Order의 totalAmounts도 변경해야 함 -> 일관성을 유지하기 위해서는 애그리거트 전체를 관리할 주체가 필요

### 애그리거트 설계 규칙

- 단순히 필드를 변경하는 Setter를 public으로 만들지 않기
  - 도메인의 의미나 의도를 표현하지 못함
  - 도메인 로직이 응용 영역이나 표현 영역으로 분산되게 만드는 원인이 됨
- 밸류 타입을 불변으로 구현
  - 상태 변경을 안전하게 관리
  - 새로운 밸류 객체를 할당하는 것으로 구현

### 트랜잭션 범위

- 트랜잭션 범위는 작을수록 좋음
- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 함 (충돌 가능성 제거)
  - 애그리거트에서 다른 애그리거트를 변경하지 않는다 -> 결합도 제거
- 여러 애그리거트 수정 필요 시, 응용 서비스에서 각각의 애그리거트를 수정

## 3.3. 리포지터리와 애그리거트

- 리포지터리는 애그리거트 단위로 존재
  - Order와 OrderLine을 각각 별도의 DB 테이블에 저장한다고 리포지터리를 각각 만들지 않는다
  - Order가 애그리거트 루트이고 OrderLine은 애그리거트에 속하는 구성요소이므로 Order 리포지터리만 존재
- 애그리거트 전체를 저장소에 영속화해야 함

## 3.4. ID를 이용한 애그리거트 참조

- 애그리거트 간 직접 참조를 피하고 ID를 통해 참조
- 필드 직접 참조를 통한 구현 장점
  - JPA의 @ManyToOne, @OneToOne과 같은 어노테이션을 이용해 필드를 통한 다른 애그리거트 참조를 쉽게 구현할 수 있음
  - 다른 애그리거트의 데이터를 객체 탐색을 통해 조회할 수 있음
- 필드 직접 참조를 통한 구현 단점
  - 편한 탐색 오용
    - 한 애그리거트에서 다른 애그리거트 객체에 접근할 수 있다면, 다른 애그리거트의 상태를 쉽게 변경할 수 있음
  - 성능에 대한 고민
    - 애그리거트를 직접 참조하면 지연 로딩, 즉시 로딩 중 어떤 것을 사용해야 할 지 다양한 경우의 수를 고민해야 함
  - 확장 어려움
    - 초기에는 단일 DBMS를 사용할 수 있지만, 사용자가 늘고 트래픽이 증가하면 부하를 분산하기 위해 하위 도메인별로 시스템을 분리하기 시작함
    - 하위 도메인마다 서로 다른 DBMS를 사용한다면, 애그리거트 루트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없음
- ID를 이용하여 애그리거트 참조를 구현하자
  - 애그리거트 내의 엔티티를 참조할 때는 객체 레퍼런스로, 다른 애그리거트를 참조할 때는 ID 참조를 사용

### ID를 이용한 참조와 조회 성능

- N+1문제
  - 다른 애그리거트를 ID로 참조하면 참조하는 여러 애그리거트를 읽어야 할 때 조회 속도가 문제될 수 있음
  - 예를 들어, 주문 목록과 연관된 상품 애그리거트와 회원 애그리거트를 읽어올 때 각 주문마다 상품과 회원 애그리거트를 읽어온다고 해보면
  - 한 DBMS에 데이터가 있다면 조인을 통해 한 번에 모든 데이터를 가져올 수 있음에도 불구하고 주문마다 상품과 회원 정보를 읽어오는 쿼리를 실행하게 됨
- 해결 방안
  - 전용 조회 쿼리 사용 (데이터 조회를 위한 별도 DAO를 만들고 DAO의 조회 메소드에서 세타 조인을 이용해서 한 번의 쿼리로 필요한 데이터를 로딩)
  - 애그리거트마다 서로 다른 저장소를 사용하는 경우는 한 번의 쿼리로 관련 애그리거트를 조회할 수 없음 -> 이런 경우, 조회 성능을 높이기 위해 캐시를 적용하거나 조회 전용 저장소를 따로 구성
    - 장점: 시스템의 처리량을 높일 수 있음
    - 단점: 코드가 복잡해짐

## 3.5. 애그리거트 간 집합 연관

### 1:N, N:1

- 개념적으로는 1:N 연관이 있더라도, 실제 구현에 반영하지는 않음
  - 대신 N:1 관계를 사용

### M:N

- 개념적으로는 양쪽 애그리거트에 컬렉션으로 연관을 만들지만, 실제 구현에서는 단방향 M:N연관만 구현하는 경우가 많음
- RDBMS를 이용해서 M:N연관을 구현하려면 조인 테이블을 사용함
  - JPA를 이용하면 매핑 설정을 통해 ID 참조를 이용한 M:N 단방향 연관을 구현할 수 있음

## 3.6. 애그리거트를 팩토리로 사용

- 도메인 기능을 구현하기 위해 애그리거트를 팩토리로 사용해보자
  - 도메인의 응집도가 높아짐
- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면, 애그리거트에 팩토리 메소드를 구현해보자
  - 생성할 때 필요한 데이터의 일부를 직접 제공하면서 동시에 중요한 도메인 로직을 함께 구현할 수 있게 됨
