## JPA를 이용한 리포지터리 구현

### 모듈 위치

<img src="https://file.notion.so/f/f/412c9b0a-ec55-45df-8458-890f1703ea17/94872f35-ee88-4272-973a-ff8d9dbd2899/Untitled.png?id=41b0ead3-b5fb-4cac-9d2a-b89b3fad7bc2&table=block&spaceId=412c9b0a-ec55-45df-8458-890f1703ea17&expirationTimestamp=1719842400000&signature=xoOjGt_rfXpyVQjnoz0IpTaeIEeeRpCOEJdcXIjjttA&downloadName=Untitled.png" width = "50%" height = "50%">


- 2장에서 언급했듯이 리포지터리와 인터페이스는 애그리거트와 같이 도메인 영역에 속한다.
- 리포지터리를 구현한 클래스는 인프라 스트럭처 영역에 속한다.

<aside>
✅ 팀에 따라 리포지터리 구현 클래스를 domain.impl과 같은 패키지에 위치시킬 수 있지만 좋은 방법은 아니다.

가능하면 리포지터리 구현클래스는 인프라스트럭처 영역에 위치시켜 의존을 낮춰야한다.

</aside>

## 리포지터리 기본 기능 구현

### 조회, 저장

리포지터리의 기본적인 기능은 다음과 같다.

- ID로 애그리거트 조회
- 애그리거트 저장

두 메서드를 위한 리포지터리 인터페이스는 애그리거트 루트를 기준으로 작성한다.

한 애그리거트 안에는 다양한 객체가 포함되는데 이들 중 루트 엔티티를 기준으로 인터페이스를 작성한다.

### 수정

애그리거트를 수정할 때는 따로 메서드를 추가 할 필요는 없다.

JPA를 사용하면 변경감지를 통해 트랜잭션 범위에서 변경한 데이터를 자동으로 DB에 반영한다.

한 트랜잭션 내에서 수정 작업을 한 뒤 트랜잭션 커밋시에 UPDATE 쿼리가 실행된다.

### 삭제

애그리거트를 삭제하는 기능이 필요할 때는 애그리거트 객체나 ID를 파라미터로 받아 삭제 메서드를 추가할 수 있다.

<aside>
✅ 삭제 요구사항이 있어도 실제로 삭제하는 경우는 많지 않다.
관리자 기능에서 삭제한 데이터까지 조회해야 하거나 일정 기간 보관해야 할 때가 있기 때문에 soft delete를 통한 방식으로 구현한다.

</aside>

## 스프링 데이터 JPA를 이용한 리포지터리 구현

스프링 데이터 JPA는 지정한 규칙에 맞게 리포지터리 인터페이스를 정의함녀 리포지터리를 구현한 객체를 알아서 만들어 스프링 빈으로 등록해준다.

다음 규칙에 따라 인터페이스를 작성하면 스프링 빈 객체를 자동으로 등록한다.

- org.springframework.data.repository.Repository<T, ID>
- T는 엔티티 타입, ID는 식별자 타입

```java
import org.springframework.data.repository.Repository;
import java.util.Optional;

public interface OrderRepository extends Repository<Order, OrderNo> {
	Optional<Order> findById(OrderNo id);
	
	void save(Order order);
}
```

스프링 데이터 JPA 사용 시에 지정한 규칙에 맞게 메서드를 작성해야 한다.

**저장**

- Order save(Order order)
- void save(Order order)

**조회**

- Order findById(OrderNo id) - 데이터 없을 시 null 리턴
- Optional<Order> findById(OrderNo id) - 데이터 없을 시 Optional 리턴

**리스트 조회**

- List<Order> findAll()

## 매핑 구현

### 엔티티와 밸류 기본 매핑

- 애그리거트 루트는 엔티티이므로 @Entity로 매핑 설정한다.
- 밸류는 @Embedded로 매핑 설정한다.
- 밸류 타입 프로퍼티는 @Embedded로 매핑 설정한다.

### 기본 생성자

엔티티와 밸류의 생성자는 객체를 생성할 때 필요한 것을 전부 전달받는다.

밸류가 불변타입이라면 생성 시점에 필요한 값을 모두 전달받으므로 기본 생성자가 필요가 없다.

하지만 JPA에서 @Entity와 @Embeddable 클래스를 매핑하려면 기본 생성자를 제공해야 한다.

이러한 기본 생성자는 JPA 프로바이더가 객체를 생성할 때만 사용한다.

그렇기에 접근제한자를 조정하는 방법도 있다.

### 필드 접근 방식 사용

JPA는 필드와 메서드의 두가지 방식으로 매핑을 처리할 수 있다.

메서드 방식을 사용하려면 프로퍼티를 위한 get/set 메서드를 구현해야 한다.

→ 도메인의 의도가 사라지고 객체가 아닌 데이터기반으로 엔티티를 구현할 가능성이 높아진다.

→ 캡슐화를 깨는 원인이 될 수 있다.

객체가 제공할 기능을 중심으로 엔티티를 구현하게끔 유도하려면 필드 방식 매핑을 선택해서 불필요한 get/set 메서드를 구현하지 말아야 한다.

### AttributeConverter를 이용한 밸류 매핑 처리

밸류 타입의 프로퍼티를 한 개 컬럼에 매핑해야 할 때가 있다.

이럴 때는 @Embedded 애너테이션으로는 처리할 수 없다. AttrubuteConverter를 활용해야 한다.

AttributeConver 인터페이스를 구현한 클래스를 두면 지정한 타입의 프로퍼티에 대해 Converter를 자동으로 적용해준다.

### 밸류 컬렉션 : 별도 테이블 매핑

한 엔티티에서 한 개이상의 밸류 타입 프로퍼티를 가질 수 있다.

다음처럼 List 타입을 이용해서 컬렉션을 프로퍼티로 지정할 수 있다.

```java
public class Order {
	private List<OrderLine> orderLines;
	...
}
```

### 밸류 컬렉션 : 한 개 컬럼 매핑

밸류 컬렉션을 별도 테이블이 아닌 한 개 칼럼에 저장해야 할 때가 있다.

예를 들어 도메인 모델에는 이메일 주소 목록을 Set으로 보관하고 DB에는 한 개 칼럼에 콤마로 구분해서 저장하는 경우다.

이럴 때에도 AttributeConverter를 활용하여 밸류 컬렉션을 한 개 칼럼에 쉽게 매핑할 수 있다.

### 별도 테이블에 저장하는 밸류 매핑

애그리거트에서 루트 엔티티를 뺀 나머지 구성요소는 대부분 밸류이다.

루트 엔티티 외에 또 다른 엔티티가 있다면 진짜 엔티티인 지 의심해 봐야 한다.

단지 별도 테이블에 데이터를 저장한다고 해서 엔티티인 것은 아니다.

애그리거트에 속한 객체가 밸류인 지  엔티티인 지 구분하는 방법은 고유 식별자를 갖는지를 확인하는 것이다.

그런데 별도 테이블에 저장하고 테이블에 PK가 있다고 해서 고유 식별자를 가지고 있다는 것은 아니다.

PK가 루트 엔티티의 테이블과 데이터를 연결하기 위함이라면 고유 식별자를 가지고 있는 것이 아니다.

### 밸류 컬렉션을 @Entity로 매핑하기

개념적으로 밸류인데 팀 표준 때문에 @Entity로 매핑해야 할 때도 있다.

그런 경우엔 독자적인 라이프 사이클을 갖지 않기 때문에 cascade 속성을 설정해야 한다.

코드 유지보수와 성능 측면을 고려하여 Entity로 매핑할 지 Embedded로 매핑할 지 선택해야 한다.

## 애그리거트 로딩 전략

JPA 매핑을 설정할 때 항상 기억해야 할 점은 애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다는 것이다.

조회 시점에서 애그리거트를 완전한 상태가 되도록 하려면 연관 매핑의 조회 방식을 즉시로딩(EAGER)으로 설정하면 된다.

→ 하지만 즉시로딩을 적용 시 한번의 조회에 대해 예상치 못한 레코드 결과가 반환될 수 있다.

조회 성능 문제 때문에 즉시 로딩 방식을 사용하지만 위의 문제 때문에 데이터 개수가 많아지면 성능을 검토해봐야 한다.

또한 루트 엔티티를 로딩하는 시점에 모든 객체를 로딩해야 하는 것은 아니다.

- 상태를 변경하는 경우에는 실제로 상태를 변경하는 시점에 필요한 구성요소만 로딩해도 문제가 되지 않는다.
    - 일반적으로 조회기능이 상태 변경기능보다 빈도가 훨씬 높기 때문에 지연로딩으로 인한 추가 쿼리가 큰 문제가 되진 않는다.
- 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 별도의 조회 전용 기능과 모델을 구현하는 방식이 더 유리하다.

이런 이유로 모든 연관을 즉시 로딩으로 설정할 필요가 없다.

지연 로딩은 동작 방식이 항상 동일해서 즉시 로딩처럼 경우의 수를 따질 필요가 없는 장점이 있다.

## 애그리거트의 영속성 전파

애그리거트 루트를 조회할 때뿐만 아니라 저장, 삭제할 때도 하나로 처리해야한다.

- 저장 메서드는 루트만 저장하면 안되고 애그리거트에 속한 모든 객체를 저장해야한다.
- 삭제 메서드는 루트 뿐만아니라 애그리거트에 속한 모든 객체를 삭제해야 한다.

@Embedded 매핑 타입은 함께 저장되고 삭제되므로 cascade 속성을 설정하지 않아도 된다.

@Entity 타입에 대한 매핑은 cascade 속성을 사용해 저장과 삭제 시에 함께 처리되도록 해야한다.

## 식별자 생성 기능

식별자를 생성하는 방식

- 사용자가 직접 생성
- 도메인 로직으로 생성
- DB를 이용한 일련번호 사용

**직접 식별자를 입력하는 경우**

- 이메일 주소처럼 사용자가 직접 식별자를 입력
- 생성 주체가 사용자이기 때문에 도메인 영역에 식별자 생성 기능을 구현할 필요 없다.

**도메인 로직으로 생성**

- 식별자 생성 규칙이 있다면 별도 서비스로 식별자 생성 기능을 분리한다.
- 식별자 생성 규칙은 도메인 규칙이므로 도메인 영역에 생성 기능을 위치시킨다.

```java
public class ProductIdService {
	public ProductId nextId() {
		... // 정해진 규칙으로 식별자 생성
	}
}
```

식별자 생성 규칙을 구현하기에 적합한 또 다른 장소는 리포지터리다.

리포지터리 인터페이스에 식별자를 생성하는 메서드를 추가하고 리포지터리 구현 클래스에서 알맞게 구현하면 된다.

**DB 자동 증가 칼럼으로 식별자 사용**

- @GeneratedValue 사용
- DB의 insert 쿼리를 실행해야 식별자가 생성되므로 도메인 객체를 생성하는 시점에는 식별자를 알 수 없다.

## 도메인 구현과 DIP

다음 구현 코드는 DIP 원칙을 어기고있다.

```java
@Entity
public class Article {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;
	...
}
```

@Entity는 구현기술에 속하므로 Article과 같은 도메인 모델은 구현 기술인 JPA에 의존하지 말아야 하는데 이 코드는 구현 기술에 의존하고 있다.

다음 리포지터리 인터페이스도 마찬가지다.

```java
public interface ArticleRepository extends Repository<Article, Long> {
	void save(Article article);
	Optional<Article> findById(Long id);
}
```

구현 기술에 대한 의존없이 도메인을 순수하게 유지하려면 스프링 데이터 JPA의 인터페이스를 상속받지 말고 다음 그림과 같은 구조로 수정해야 한다.

<img src="https://file.notion.so/f/f/412c9b0a-ec55-45df-8458-890f1703ea17/7ede0d7a-d60f-4c6d-8e57-023bf47b242f/Untitled.png?id=bd5a9904-6cef-49eb-a39e-b39c975b87ea&table=block&spaceId=412c9b0a-ec55-45df-8458-890f1703ea17&expirationTimestamp=1719842400000&signature=9BEZlsOoLpOZrQy1W96cpYL6raETn3IOctHoMfxm7Do&downloadName=Untitled.png" width = "50%" height = "50%">

DIP의 주된 이유는 저수준 구현 기술의 변경이 고수준의 미치는 영향을 최소화 하기 위함이다.

하지만 리포지터리, 도메인 모델의 구현 기술은 거의 바뀌지 않는다. 그래서 어느 정도의 타협을 하는 것도 좋다.

- JPA 전용 어노테이션을 사용하더라도 도메인 모델을 단위 테스트하는데는 문제가 없다.
- 스프링 데이터 JPA의 Repository를 상속하더라도 리포지터리 자체는 인터페이스고 테스트 가능성을 해치지 않는다.

DIP를 완벽하게 지키면 좋겠지만 개발 편의성과 실용성도 중요한 측면이기에 구조적인 유연함을 가져갈 필요가 있다.