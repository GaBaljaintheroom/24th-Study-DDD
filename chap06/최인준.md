## 표현 영역과 응용 영역

도메인 영역을 잘 만들고 도메인이 제 기능을 하려면 사용자와 도메인을 연결해주는 매개체가 필요하다.

그 역할을 응용 영역과 표현 영역에서 수행한다.

**표현 영역**

- 사용자가 요청 시에 HTTP 요청을 표현 영역에 전달한다.
- 사요자가 실행하고 싶은 기능을 판별하고 그 기능을 제공하는 응용 서비스를 실행한다.
- 실행 결과를 사용자에게 알맞은 형식으로 응답한다.

**응용 영역**

- 실제 사용자가 원하는 기능을 제공한다.
- 표현 영역에서 응용 서비스가 요구하는 형식으로 요청 값으로 변환한 뒤 요청값을 받아 실행한다.
- 표현 영역에 의존하지 않아야 한다.

## 응용 서비스의 역할

### 요청 처리

사용자의 요청을 처리하기 위해 리포지터리에서 도메인 객체를 가져와 사용한다.

사용자 입장에서 봤을 때 응용 서비스는 도메인 영역과 표현 영역을 연결해주는 창구 역할을 한다.

주로 도메인 객체 간의 흐름을 제어하기 때문에 다음과 같이 단순한 형태를 갖는다.

```java
public Result doSomeFunc(SomeReq req) {
	// 1. 리포지터리에서 애그리거트를 구한다.
	SomeAgg agg = someAggRepository.findById(req.getId());
	
	// 2. 애그리거트의 도메인 기능을 실행한다.
	add.doFunc(req.getValue())
	
	// 3. 결과를 리턴한다.
	return createSuccessResult(agg);
} 
```

→ 만약 응용ㅇ 서비스가 복잡하다면 응용 서비스가 도메인 로직의 일부를 구현하고 있을 가능성이 높다.

→ 이는 코드 중복, 로직 분산 등 코드 품질에 안 좋은 영향을 줄 수 있다.

### 트랜잭션 처리

응용 서비스는 도메인의 상태 변경을 트랜잭션으로 처리해야 한다.

→ 데이터 일관성을 지키기 위함이다.

### 도메인 로직 넣지 않기

응용서비스에 도메인 로직을 넣지말자. 다음과 같은 문제 때문이다.

1. 코드의 응집성이 떨어진다.
    1. 핵심 로직이 분산되면 로직을 파악하기 위해 여러 영역을 분석해야 한다.
2. 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다.
    1. 코드 변경이 어려워지는 결과를 얻게 된다.

물론 코드 중복을 막기 위해 별도의 보조 클래스를 만들 수 있지만, 애초에 도메인 영역에 로직을 구현했으면 응용 서비스는 그 기능을 사용하기만 하면 된다.

## 응용 서비스의 구현

### 응용 서비스의 크기

응용 서비스는 보통 다음의 두 가지 방법 중 한 가지 방식으로 구현한다.

- 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
- 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기

한 클래스에서 특정 도메인의 모든 기능을 구현하면

- 각 기능에서 동일 로직에 대한 코드 중복을 제거할 수 있다.
- 클래스의 크기가 커진다는 것은 단점이다.

클래스가 커진다는 것은 연관성이 적은 코드가 한 클래스에 함께 위치할 가능성이 높아지는데 이는 코드 이해에 방해된다.

또한 엄연히 분리해야 하는 상황임에도 습관적으로 기존에 존재하는 클래스에 억지로 끼워넣게 된다.

### 기능별로 응용 서비스 클래스 분리하기

이 방식을 사용하면 클래스 개수는 많아지지만 코드 품질을 일정 수준으로 유지하는데 도움이 된다.

각 기능마다 동일한 로직이 필요한 경우에는 공통 로직은 특정 Helper 클래스를 둬 정의하면 된다.

### 응용 서비스의 인터페이스와 클래스

응용 서비스를 구현할 때 다음과 같이 인터페이스가 필요할까?

```java
public interface ChangePasswordService {
	public void changePassword(String memberId, String curPw, String newPw);
}

public class ChangePasswordServiceImpl implements ChangePasswordService {
 //...구현
 }
```

인터페이스가 필요한 상황은 구현 클래스가 여러개인 경우이다.

여러개이면 런타임에 구현 객체를 교체해야할 때 인터페이스를 유용하게 사용할 수 있다.

**하지만 그런 경우는 드물다**

이런 이유로 굳이 인터페이스를 둘 필요가 없다!

### 메서드 파라미터와 값 리턴

응용 서비스는 도메인을 이용해서 기능을 실행하는데 필요한 값을 파라미터로 전달받아야 한다.

- 값들을 여러 인자로 전달받기
- 별도의 데이터 클래스를 만들어 데이터 클래스를 인자로 받기

그리고 표현 영역에서 필요로 하는 데이터를 리턴한다.

- 식별자 리턴
- 데이터 클래스 리턴(표현 영역에서 필요로 하는)
- 애그리거트 객체 그대로 리턴

하지만 애그리거트 객체를 그대로 리턴한다는 것은 도메인의 로직을 응용, 표현 영역 두곳에서 할 수 있게 된다는 것이다.

이는 기능 실행 로직을 분산시켜 코드의 응집도를 낮추는 원인이 된다.

그러므로 확실히 표현 영역에서 필요한 데이터를 리턴하는 것이 좋다.

### 표현 영역에 의존하지 않기

응용 서비스의 파라미터 타입으로 표현 영역과 관련된 타입이 들어오면 안된다.

다음 두 예시를 생각해보자.

- HttpServletRequest
- HttpSession

위처럼 표현 영역 관련 타입이 들어오면 응용 서비스만 단독으로 테스트 하기가 어려워진다.

또한 표현 영역의 구현이 변경되면 응용 서비스의 구현도 함께 변경해야 한다.

제일 심각한 문제는 응용 서비스가 표현 영역의 역할까지 대신하게 될 수도 있다.

```java
public class AuthenticationService {
	/// HttpServletRequest를 받아 세션에 인증 정보 담는 로직
}
```

세션은 표현 영역의 상태에 해당되는데 응용 서비스에서 변경해버리면 표현 영역의 코드만으로 표현 영역의 상태를 알 수가 없다. 즉, 응집도가 깨진다.

## 표현 영역

표현 영역의 책임은 크게 다음과 같다.

- 사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공하고 제어한다.
- 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다.
- 사용자의 세션을 관리한다.

응용 서비스의 실행 결과를 제공할 때 사용자에게 알맞은 형식으로 제공해야 한다.

## 값 검증

값 검증은 표현 영역과 응용 서비스 두 곳에서 모두 수행할 수 있다.

응용 서비스에서 값 유효성을 확인할 목적으로 익셉션을 사용하면 사용자에게 좋지 않은 경험을 제공할 수 있다.

예를 들어 값을 검사하는 시점에 여러 값 중 첫번째 값에서 익셉션이 발생하면 나머지 항목에 대해서는 값 검증을 하지 않게 된다.

이러면 사용자는 나머지 항복에 대해서 값이 올바른지는 알 수가 없다.

→ 이런 불편함을 해소하기 위햇 응용 서비스에서 에러 코드를 모아 하나의 익셉션으로 발생시키는 방법이 있다.

표현 영역에서 필수 값과 값의 형식을 검사하면 응용 서비스는 ID 중복 여부와 같은 논리적 오류만 검사하면 된다.

즉 응용, 표현 영역이 값 검증을 나눠서 수행하는 것이다.

- 표현 영역 : 필수 값, 값의 형식, 범위 등을 검증
- 응용 서비스 : 데이터의 존재 유무 검증

## 권한 검사

단순한 시스템은 인증 여부만 검사하면 되지만 어떤 시스템은 권한에 따라 사용 가능한 기능이 달라지기도 한다.

이런 다양한 상황을 충족시키기 위해 스프링 시큐리티 같은 프레임워크는 유연하고 확장 가능한 구조를 갖고 있다.

보통 다음 세 곳에서 권한 검사를 수행할 수 있다.

- 표현 영역
- 응용 서비스
- 도메인

표현 영역에서 할 수 있는 검사는 인증 유무이다.

권한에 따라 접근제어를 할 수 있는데 보통 서블릿 필터에서 수행한다.

<img src="https://file.notion.so/f/f/412c9b0a-ec55-45df-8458-890f1703ea17/7f533051-e62b-40b0-b0cb-83c381638bcd/Untitled.png?id=80ec5cf3-27e0-4312-9886-65bd68ac7263&table=block&spaceId=412c9b0a-ec55-45df-8458-890f1703ea17&expirationTimestamp=1721217600000&signature=uhePWkl-LJvq-l0LqJqq5RQ7aVVTBzEJPTmiqBCPaNI&downloadName=Untitled.png" width="50%" height="50%">

URL만으로 접근제어를 할 수 없는 경우 응용 서비스의 메서드 단위로 권한 검사를 수행해야 한다.

## 조회 전용 기능과 응용 서비스

앞 장에서 조회 전용 모델과 DAO를 만드는 내용을 다뤘다.

서비스에서 조회 전용 기능을 사용하면 다음과 같이 서비스 코드가 단순해진다.

```java
public class OrderListService {
	public List<OrderView> getOrderList(String ordererId) {
			return orderViewDao.selectByOrderer(ordererId);
		}
}
```

단일 쿼리만 실행하는 조회 전용 기능이어서 트랜잭션이 필요하지도 않다.

이런 경우엔 서비스를 만들 필요 없이 표현 영역에서 바로 조회 전용 기능을 사용해도된다.