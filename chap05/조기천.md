# 5. 스프링데이터 JPA를 이용한 조회 기능


## 5.1 시작에 앞서

- CQRS : 명령(command) 모델과 조회(Query) 모델을 분리하는 패턴


## 5.2 검색을 위한 스펙

Specification : 검색 조건을 다양하게 조합해야 할 때 사용
애그리거트가 특정 조건을 충족하는지 검사할 때 사용하는 인터페이스

리포지터리가 스펙을 이용해서 검색 대상을 걸러주므로, 
특정 조건을 충족하는 애그리거트를 찾고 싶으면 원하는 스펙을 생성해서 
리포지터리에 전달해주기만 하면 된다.

## 5.3 스프링 데이터 JPA를 이용한 스펙 구현

- 스펙 인터페이스에서 지네릭 타입 파라미터는 JPA의 엔티티타입을 의미
- JPA 크리테리아 API에서 조건을 표현할 때 Predicate를 생성

정적 메타 모델은 @StaticMetaModel 애너테이션을 이용해서 관련 모델을 지정.
정적 메타 모델 클래스를 직접 작성할 수 있지만 하이버네이트와 같은 JPA 프로바이더는 정적 메타 모델을 생성하는 도구를 제공하고 있으므로 이들 도구를 사용하면 편리하다


## 5.4 리포지터리/DAO에서 스팩 사용하기

스펙을 충족하는 엔티티를 검색하고 싶다면 findAll() 메서드를 사용하면 된다. 

findAll() 메서드는 스펙 인터페이스를 파라미터로 갖는다.

## 5.5 스펙 조합

스프링 데이터 JPA가 제공하는 스펙 인터페이스는 스펙을 조합할 수 있는 두 메서드를 제공하고 있다.

- and와 or

and()와 or() 메서드는 기본 구현을 가진 디폴트 메서드이다. 
and() 메서드는 두 스펙을 모두 충족하는 조건을 표현하는 스펙을 생성하고 

or() 메서드는 두 스펙 중 하나 이상을 충족하는 조건을 표현하는 스펙을 생성한다.

- not
스펙 인터페이스는 not() 메서드도 제공한다. 이는 조건을 반대로 적용할 때 사용한다.

- where
null 가능성이 있는 스펙 객체와 다른 스펙을 조합해야 할 때가 있다.
where() 메서드를 사용하면 이런 귀찮음을 줄일 수 있다. 


## 5.6 정렬 지정하기

스프링 데이터 JPA는 두 가지 방법을 사용해서 정렬을 지정이 가능하다

1. 메서드 이름에 OrderBy를 사용해서 정렬 기준 지정
2. Sort를 인자로 전달


### 메서드 이름에 OrderBy 사용
findByOrdererIdOrderByNumberDesc 메서드는 다음 조회 쿼리를 생성한다.

- ordererId 프로퍼티 값을 기준으로 검색 조건 지정
- number 프로퍼티 값을 역순으로 정렬

- 장점 : 간단함
- 단점 : 
정렬 기준 프로퍼티가 두 개 이상이면 메서드 이름이 길어짐
메서드 이름으로 정렬 순서가 정해지기 때문에 상황에 따라 정렬 순서를 변경할 수 없음

### Sort 타입 사용

스프링 데이터 JPA는 파라미터로 전달받은 Sort를 사용해서 알맞게 정렬 쿼리를 생성한다.


## 5.7 페이징 처리하기

목록을 보여줄 때 전체 데이터 중 일부만 보여주는 페이징 처리는 기본이다. 

스프링 데이터 JPA는 페이징 처리를 위해 Pageable 타입을 이용한다. 

Sort 타입과 마찬가지로 find 메서드에 Pageable 타입 파라미터를 사용하면 페이징을 자동으로 처리해준다.

## 5.8 스펙 조합을 위한 스펙 빌더 클래스

스펙을 생성하다 보면 조건에 따라 스펙을 조합해야 할 때가 있다.

스펙 빌더를 사용한다면 코드 가독성과 구조를 단순화 시킬 수 있다,

```java
Specification<MemberData> spec = SpecBuilder.builder (MemberData.class)
		.ifTrue(searchRequest.isOnlyNotBlocked(),
        		() -> MemberDataSpecs.nonBlocked())
		.ifHasText(searchRequest.getName,
        		name -> MemberDataSpecs.nameLike(searchRequest.getName()))
		.toSpec();
List<MemberData> result = memberDataDao.findAll(spec, PageRequest.of(0, 5));
```

## 5.9 동적 인스턴스 생성
JPA는 쿼리 결과에서 임의의 객체를 동적으로 생성할 수 있는 기능을 제공하고 있다.

- @Query

조회 전용 모델을 만드는 이유는 표현 영역을 통해 사용자에게 데이터를 보여주기 위함이다.
많은 웹 프레임워크는 새로 추가한 밸류 타입을 알맞은 형식으로 출력하지 못하므로 값을 기본 타입으로 변환하면 편리하다.

동적 인스턴스의 장점은 JPQL을 그대로 사용하므로 객체 기준으로 쿼리를 작성하면서도 
동시에 지연/즉시 로딩과 같은 고민 없이 원하는 모습으로 데이터를 조회할 수 있다는 점이다.

## 5.10 하이버네이트 @Subselect 사용
하이버네이트는 JPA 확장 기능으로 @Subselect를 제공한다.
 이는 쿼리 결과를 @Entity로 매핑할 수 있는 유용한 기능이다.

- @Subselect
조회(select) 쿼리를 값으로 갖는다.
하이버네이트는 이 select 쿼리의 결과를 매핑할 테이블처럼 사용한다.
뷰를 수정할 수 없듯이 @Subselect로 조회한 @Entity 역시 수정할 수 없다.
이름처럼 @Subselect의 값으로 지정한 쿼리를 from 절의 서브 쿼리로 사용한다.
장점으로는, EntityManager.find(), JPQL, Criteria를 사용해서 조회할 수 있다. 스펙을 사용할 수 있다.

- @Immutable
하이버네이트는 @Subselect를 이용한 @Entity의 매핑 필드/프로퍼티가 변경되어도 DB에 반영하지 않고 무시한다.

- @Synchronize
해당 엔티티와 관련된 테이블 목록을 명시한다. 
하이버네이트는 로딩하기 전에 지정한 테이블과 관련된 변경이 발생하면 플러시를 먼저 한다.
