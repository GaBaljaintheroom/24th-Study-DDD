### 도메인과 그 특징

도메인이란 해결하고자 하는 문제 영역을 말한다.

- 하나의 도메인은 다시 여러 하위 도메인으로 나눌 수 있다.
- 한 하위 도메인은 다른 하위 도메인과 연동하여 완전한 기능을 제공한다.
- 특정 도메인을 구현한다 하더라도 상황에 따라 하위 도메인의 구성이 달라진다.

---

### 도메인 전문가와 개발자 간 커뮤니케이션의 중요성

특정 영역의 전문가는 해당 도메인에 대해 본인들의 원하는 기능 개발을 요구한다.

개발자는 이 요구사항을 분석하고 설계하여 코드를 작성해 구현해낸다.

하지만 이 요구사항을 잘못 이해할 경우 나중에 수정하기도 어려워지고 잘못된 프로덕트가 나올 수 있다.

요구사항을 올바르게 이해하려면 개발자와 전문가 간의 직접적인 소통이 중요하다.

---

### 도메인 모델

기본적으로 도메인 모델은 특정 도메인을 개념적으로 표현한 것이다.

예시로 주문 모델을 객체 모델로 구성하면 다음과 같이 만들 수 있다.

<img src = "https://sangjaeoh.github.io/assets/images/posts/books/1/1_3_객체기반도메인모델.png" width=40% height = 50%>

이처럼 도메인 모델을 사용하면 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는 데 도움이 된다.

위와 같은 객체 모델은 기능과 데이터를 함께 보여주기 때문에 도메인 모델링에 적합하다.

도메인 모델을 객체로만 모델링 할 수 있는 것은 아니고 다음과 같이 상태 다이어그램을 이용할 수도 있다.

<img src = "https://sangjaeoh.github.io/assets/images/posts/books/1/1_3_%EC%83%81%ED%83%9C%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8%EB%8F%84%EB%A9%94%EC%9D%B8%EB%AA%A8%EB%8D%B8.png" width=40% height=50%>

---

### 모델링 시 주의점

도메인은 다수의 하위 도메인으로 구성된다.

각 도메인이 다루는 영역은 서로 다르기 때문에 같은 용어라도 하위 도메인마다 의미가 달라질 수 있다.

그렇기에 여러 하위 도메인을 하나의 다이어그램에 모델링하면 안된다.

모델의 각 구성요소는 특정 도메인으로 한정할 때 비로소 의미가 완전해지기 때문에 각 하위 도메인마다 별도로 모델을 만들어야 한다.

---

### 도메인 모델 패턴

**1) 도메인 모델 패턴이란**

도메인 계층은 도메인의 핵심 규칙을 구현한다.

이런 도메인 규칙을 객체 지향 기법으로 구현하는 패턴이 도메인 모델 패턴이다.

중요한 점은 도메인과 관련된 중요 규칙을 해당 도메인 모델에서 구현해야한다는 점이다.

핵심 규칙을 구현한 코드는 도메인 모델에만 위치하기 때문에 규칙이 바뀌거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있게 된다.

**2) 개념 모델과 구현 모델**

개념 모델은 순수하게 문제를 분석한 결과물이다.

- DB, 트랜잭션 처리, 성능, 구현 기술 같은 것을 고려하고 있지 않기 때문에 실제 구현 시 있는 그대로 사용할 수 없다.
- 그래서 개념 모델을 구현 가능한 형태의 모델로 전환하는 과정을 거치게 된다.(구현 모델로 전환)
- 초기 이해한 도메인 지식이 시간이 지나 새로운 통찰을 얻으면서 완전히 다른 의미로 해석되는 경우가 있다.
- 그렇기에 처음부터 완벽한 개념 모델을 만들기 보다는 전체 윤곽을 이해할 수 있는 수준으로 만들어야 한다.

---

### 도메인 모델 도출

도메인 이해 없이 코딩을 할 순 없다. 도메인을 이해하고 이를 바탕으로 도메인 모델 초안을 만들어야 한다.

다음과 같은 과정을 거칠 수 있다.

- 도메인의 핵심 구성요소, 규칙, 기능을 찾는다.
- 찾은 것을 바탕으로 해당 도메인에 코드로 구현한다.
- 각 규칙, 기능을 구현 시에 목적에 맞는 네이밍을 활용한다.

마지막에 네이밍을 잘 활용해야 하는 이유는 코드도 하나의 문서화의 대상이 될 수 있기 때문이다.

도메인 관점에서 코드가 도메인을 잘 표현하면 가독성도 높아지고 문서로서 코드가 의미를 갖는다.

---

### 엔티티와 밸류

**1) 엔티티**

도출한 모델은 크게 엔티티와 밸류로 구분할 수 있다. 먼저 엔티티에 대한 정리이다.

<img src = "https://blog.kakaocdn.net/dn/J3hx7/btrLD0ABDuH/zWzHIrkehLqkBzCK5tpgT1/img.png" width="40%" height ="50%">

- 가장 큰 특징은 식별자를 가진다는 것이다.
    - 위 그림의 Order는 엔티티로서 orderNumber라는 식별자를 가진다.
- 엔티티를 생성하고 속성을 바꾸고 삭제할 때 까지 식별자는 유지된다.

**2) 엔티티의 식별자를 생성하는 방법**

- 특정 규칙에 따라 생성
    - 날짜와 시간을 이용해 생성한다면 **동시성 이슈**를 고려해야함
- UUID나 Nano ID와 같은 고유 식별자 생성기 사용
- 값을 직접 입력
    - 이메일이나 전화번호처럼 직접 입력 시 **중복 입력 방지 필요**
- 일련번호 사용(시퀀스나 DB의 자동 증가 컬럼 사용)

**3) 밸류 타입**

밸류 타입은 다음 예제 클래스를 통해 이해할 수 있다.

<img src="https://blog.kakaocdn.net/dn/9Xypt/btrLFhOVy4P/CT7n275o32kmoKKHYX7eT0/img.png" width="40%" height="50%">

- ShippingInfo는 받는 사람에 대한 데이터 필드와 주소에 대한 필드들이 있다.
    - 그림과 같이 개념적인 특성에 따라 두 개념으로 분류할 수 있다.
    - 밸류 타입은 개념적으로 완전한 하나를 표현할 때 사용하므로 위 그림에 활용하기 좋다.

```java
public class Receiver {
    private String name;
    private String phoneNumber;

    public Receiver(String name, String phoneNumber) {
        this.name = name;
        this.phoneNumber = phoneNumber;
    }

    public String getName() {
        return name;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }
}

public class Address {
    private String address1;
    private String address2;
    private String zipcode;

    public Address(String address1, String address2, String zipcode) {
        this.address1 = address1;
        this.address2 = address2;
        this.zipcode = zipcode;
    }
}
```

위와 같이 Receiver는 ‘받는 사람’ 이라는 하나의 도메인 개념을 표현하고 Address는 ‘주소’를 표현한다.

위와 같이 밸류 타입을 정의하면 ShippingInfo의 필드를 개념적으로 분류해 더 간단히 할 수 있다.

밸류 타입은 개념적으로 완전한 하나를 잘 표현할 수 있다는 장점만 있는 것이 아니다.

다음과 같은 특징들이 더 있다.

- 하나의 데이터를 가진 밸류 타입이더라도 특정 필드가 어떤 것을 의미하는 지 쉽게 알 수 있다.
- 밸류 타입을 위한 기능을 추가할 수 있다.
    - 예를 들어 Receiver 도메인만이 가지는 기능들을 정의할 수 있다.
- 식별자를 정의할 때에도 밸류 타입을 활용하면 타입 자체로 식별자임을 쉽게 알 수 있다.

**3) set 메소드 지양(그냥 쓰지말자)**

- set 메소드는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.
    - set은 단순히 값을 설정한다는 의미를 지니기 때문이다.
- 습관적인 set 메소드는 필드값만 변경하고 끝나기 때문에 상태 변경과 관련된 도메인 지식이 코드에서 사라진다.
- set 메소드로 필드를 채우려 한다면 도메인 객체를 생성할 때 온전하지 않은 상태가 될 수 있다.
    - 생성 시점에 필요한 것을 모두 전달해주어야 한다.

---

### 도메인 용어와 유비쿼터스 언어

개발할 때 도메인에서 사용하는 용어는 매우 중요하다.

도메인에서 사용하는 용어를 코드에 반영하지 않으면 개발자는 코드의 의미를 해석해야 한다.

다음은 나쁜 예시의 코드다.

```java
public OrderState {
	STEP1, STEP2, STEP3, STEP4, STEP5, STEP6;
}
```

실제 주문 상태는 다양하게 있지만 상태를 단순히 6단계로 보고 표현한 예시다.

이 상황이라면 코드를 구현하면서 각 STEP이 무엇을 의미하는 지 항상 해석해야 한다.

또한 회의에서 나온 도메인 용어에 대해 개발자는 그 용어가 어떤 STEP인 지 또 해석이 필요하다.

다음은 올바른 예시 코드다.

```java
public enum OrderState {
	PAYMENT_WATING, PREPARING, SHIPPED, DELIVERING, DELIVERY_COMPLETED
}
```

나쁜 예에서 봤던 용어 → 코드, 코드 → 용어 간 해석 과정이 필요 없어지게 되었다.

이 예시들로 언어의 중요함을 알 수 있다.